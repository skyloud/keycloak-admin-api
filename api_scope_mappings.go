/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ScopeMappingsAPIService ScopeMappingsAPI service
type ScopeMappingsAPIService service

type ApiDeleteClientScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientScopeMappingsClientExecute(r)
}

/*
DeleteClientScopeMappingsClient Method for DeleteClientScopeMappingsClient

Remove client-level roles from the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiDeleteClientScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiDeleteClientScopeMappingsClientRequest {
	return ApiDeleteClientScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientScopeMappingsClientExecute(r ApiDeleteClientScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientScopeMappingsRealmExecute(r)
}

/*
DeleteClientScopeMappingsRealm Method for DeleteClientScopeMappingsRealm

Remove a set of realm-level roles from the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiDeleteClientScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientScopeMappingsRealm(ctx context.Context, realm string, id string) ApiDeleteClientScopeMappingsRealmRequest {
	return ApiDeleteClientScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientScopeMappingsRealmExecute(r ApiDeleteClientScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientScopeScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientScopeScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientScopeScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientScopeScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientScopeScopeMappingsClientExecute(r)
}

/*
DeleteClientScopeScopeMappingsClient Method for DeleteClientScopeScopeMappingsClient

Remove client-level roles from the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiDeleteClientScopeScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientScopeScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiDeleteClientScopeScopeMappingsClientRequest {
	return ApiDeleteClientScopeScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientScopeScopeMappingsClientExecute(r ApiDeleteClientScopeScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientScopeScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientScopeScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientScopeScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientScopeScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientScopeScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientScopeScopeMappingsRealmExecute(r)
}

/*
DeleteClientScopeScopeMappingsRealm Method for DeleteClientScopeScopeMappingsRealm

Remove a set of realm-level roles from the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiDeleteClientScopeScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientScopeScopeMappingsRealm(ctx context.Context, realm string, id string) ApiDeleteClientScopeScopeMappingsRealmRequest {
	return ApiDeleteClientScopeScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientScopeScopeMappingsRealmExecute(r ApiDeleteClientScopeScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientScopeScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientTemplateScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientTemplateScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientTemplateScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientTemplateScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientTemplateScopeMappingsClientExecute(r)
}

/*
DeleteClientTemplateScopeMappingsClient Method for DeleteClientTemplateScopeMappingsClient

Remove client-level roles from the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiDeleteClientTemplateScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientTemplateScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiDeleteClientTemplateScopeMappingsClientRequest {
	return ApiDeleteClientTemplateScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientTemplateScopeMappingsClientExecute(r ApiDeleteClientTemplateScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientTemplateScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientTemplateScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientTemplateScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientTemplateScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientTemplateScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientTemplateScopeMappingsRealmExecute(r)
}

/*
DeleteClientTemplateScopeMappingsRealm Method for DeleteClientTemplateScopeMappingsRealm

Remove a set of realm-level roles from the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiDeleteClientTemplateScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) DeleteClientTemplateScopeMappingsRealm(ctx context.Context, realm string, id string) ApiDeleteClientTemplateScopeMappingsRealmRequest {
	return ApiDeleteClientTemplateScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) DeleteClientTemplateScopeMappingsRealmExecute(r ApiDeleteClientTemplateScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.DeleteClientTemplateScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeMappingsRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsExecute(r)
}

/*
GetClientScopeMappings Method for GetClientScopeMappings

Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeMappingsRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappings(ctx context.Context, realm string, id string) ApiGetClientScopeMappingsRequest {
	return ApiGetClientScopeMappingsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsExecute(r ApiGetClientScopeMappingsRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsClientRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientScopeMappingsClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsClientExecute(r)
}

/*
GetClientScopeMappingsClient Method for GetClientScopeMappingsClient

Get the roles associated with a client’s scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiGetClientScopeMappingsClientRequest {
	return ApiGetClientScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClientExecute(r ApiGetClientScopeMappingsClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsClientAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientScopeMappingsClientAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsClientAvailableExecute(r)
}

/*
GetClientScopeMappingsClientAvailable Method for GetClientScopeMappingsClientAvailable

The available client-level roles Returns the roles for the client that can be associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeMappingsClientAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClientAvailable(ctx context.Context, realm string, id string, client string) ApiGetClientScopeMappingsClientAvailableRequest {
	return ApiGetClientScopeMappingsClientAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClientAvailableExecute(r ApiGetClientScopeMappingsClientAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsClientAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsClientCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	client              string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientScopeMappingsClientCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientScopeMappingsClientCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientScopeMappingsClientCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsClientCompositeExecute(r)
}

/*
GetClientScopeMappingsClientComposite Method for GetClientScopeMappingsClientComposite

Get effective client roles Returns the roles for the client that are associated with the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeMappingsClientCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClientComposite(ctx context.Context, realm string, id string, client string) ApiGetClientScopeMappingsClientCompositeRequest {
	return ApiGetClientScopeMappingsClientCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsClientCompositeExecute(r ApiGetClientScopeMappingsClientCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsClientComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsRealmRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeMappingsRealmRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsRealmExecute(r)
}

/*
GetClientScopeMappingsRealm Method for GetClientScopeMappingsRealm

Get realm-level roles associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealm(ctx context.Context, realm string, id string) ApiGetClientScopeMappingsRealmRequest {
	return ApiGetClientScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealmExecute(r ApiGetClientScopeMappingsRealmRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsRealm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsRealmAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeMappingsRealmAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsRealmAvailableExecute(r)
}

/*
GetClientScopeMappingsRealmAvailable Method for GetClientScopeMappingsRealmAvailable

Get realm-level roles that are available to attach to this client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeMappingsRealmAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealmAvailable(ctx context.Context, realm string, id string) ApiGetClientScopeMappingsRealmAvailableRequest {
	return ApiGetClientScopeMappingsRealmAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealmAvailableExecute(r ApiGetClientScopeMappingsRealmAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsRealmAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeMappingsRealmCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientScopeMappingsRealmCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientScopeMappingsRealmCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientScopeMappingsRealmCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeMappingsRealmCompositeExecute(r)
}

/*
GetClientScopeMappingsRealmComposite Method for GetClientScopeMappingsRealmComposite

Get effective realm-level roles associated with the client’s scope What this does is recurse any composite roles associated with the client’s scope and adds the roles to this lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeMappingsRealmCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealmComposite(ctx context.Context, realm string, id string) ApiGetClientScopeMappingsRealmCompositeRequest {
	return ApiGetClientScopeMappingsRealmCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeMappingsRealmCompositeExecute(r ApiGetClientScopeMappingsRealmCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeMappingsRealmComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeScopeMappingsRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsExecute(r)
}

/*
GetClientScopeScopeMappings Method for GetClientScopeScopeMappings

Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeScopeMappingsRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappings(ctx context.Context, realm string, id string) ApiGetClientScopeScopeMappingsRequest {
	return ApiGetClientScopeScopeMappingsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsExecute(r ApiGetClientScopeScopeMappingsRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsClientRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientScopeScopeMappingsClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsClientExecute(r)
}

/*
GetClientScopeScopeMappingsClient Method for GetClientScopeScopeMappingsClient

Get the roles associated with a client’s scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiGetClientScopeScopeMappingsClientRequest {
	return ApiGetClientScopeScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClientExecute(r ApiGetClientScopeScopeMappingsClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsClientAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientScopeScopeMappingsClientAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsClientAvailableExecute(r)
}

/*
GetClientScopeScopeMappingsClientAvailable Method for GetClientScopeScopeMappingsClientAvailable

The available client-level roles Returns the roles for the client that can be associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeScopeMappingsClientAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClientAvailable(ctx context.Context, realm string, id string, client string) ApiGetClientScopeScopeMappingsClientAvailableRequest {
	return ApiGetClientScopeScopeMappingsClientAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClientAvailableExecute(r ApiGetClientScopeScopeMappingsClientAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsClientAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsClientCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	client              string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientScopeScopeMappingsClientCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientScopeScopeMappingsClientCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientScopeScopeMappingsClientCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsClientCompositeExecute(r)
}

/*
GetClientScopeScopeMappingsClientComposite Method for GetClientScopeScopeMappingsClientComposite

Get effective client roles Returns the roles for the client that are associated with the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientScopeScopeMappingsClientCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClientComposite(ctx context.Context, realm string, id string, client string) ApiGetClientScopeScopeMappingsClientCompositeRequest {
	return ApiGetClientScopeScopeMappingsClientCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsClientCompositeExecute(r ApiGetClientScopeScopeMappingsClientCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsClientComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsRealmRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeScopeMappingsRealmRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsRealmExecute(r)
}

/*
GetClientScopeScopeMappingsRealm Method for GetClientScopeScopeMappingsRealm

Get realm-level roles associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealm(ctx context.Context, realm string, id string) ApiGetClientScopeScopeMappingsRealmRequest {
	return ApiGetClientScopeScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealmExecute(r ApiGetClientScopeScopeMappingsRealmRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsRealm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsRealmAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeScopeMappingsRealmAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsRealmAvailableExecute(r)
}

/*
GetClientScopeScopeMappingsRealmAvailable Method for GetClientScopeScopeMappingsRealmAvailable

Get realm-level roles that are available to attach to this client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeScopeMappingsRealmAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealmAvailable(ctx context.Context, realm string, id string) ApiGetClientScopeScopeMappingsRealmAvailableRequest {
	return ApiGetClientScopeScopeMappingsRealmAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealmAvailableExecute(r ApiGetClientScopeScopeMappingsRealmAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsRealmAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeScopeMappingsRealmCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientScopeScopeMappingsRealmCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientScopeScopeMappingsRealmCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientScopeScopeMappingsRealmCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeScopeMappingsRealmCompositeExecute(r)
}

/*
GetClientScopeScopeMappingsRealmComposite Method for GetClientScopeScopeMappingsRealmComposite

Get effective realm-level roles associated with the client’s scope What this does is recurse any composite roles associated with the client’s scope and adds the roles to this lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeScopeMappingsRealmCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealmComposite(ctx context.Context, realm string, id string) ApiGetClientScopeScopeMappingsRealmCompositeRequest {
	return ApiGetClientScopeScopeMappingsRealmCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientScopeScopeMappingsRealmCompositeExecute(r ApiGetClientScopeScopeMappingsRealmCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientScopeScopeMappingsRealmComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientTemplateScopeMappingsRequest) Execute() (*MappingsRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsExecute(r)
}

/*
GetClientTemplateScopeMappings Method for GetClientTemplateScopeMappings

Get all scope mappings for the client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientTemplateScopeMappingsRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappings(ctx context.Context, realm string, id string) ApiGetClientTemplateScopeMappingsRequest {
	return ApiGetClientTemplateScopeMappingsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MappingsRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsExecute(r ApiGetClientTemplateScopeMappingsRequest) (*MappingsRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MappingsRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsClientRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientTemplateScopeMappingsClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsClientExecute(r)
}

/*
GetClientTemplateScopeMappingsClient Method for GetClientTemplateScopeMappingsClient

Get the roles associated with a client’s scope Returns roles for the client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientTemplateScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiGetClientTemplateScopeMappingsClientRequest {
	return ApiGetClientTemplateScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClientExecute(r ApiGetClientTemplateScopeMappingsClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsClientAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetClientTemplateScopeMappingsClientAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsClientAvailableExecute(r)
}

/*
GetClientTemplateScopeMappingsClientAvailable Method for GetClientTemplateScopeMappingsClientAvailable

The available client-level roles Returns the roles for the client that can be associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientTemplateScopeMappingsClientAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClientAvailable(ctx context.Context, realm string, id string, client string) ApiGetClientTemplateScopeMappingsClientAvailableRequest {
	return ApiGetClientTemplateScopeMappingsClientAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClientAvailableExecute(r ApiGetClientTemplateScopeMappingsClientAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsClientAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsClientCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	client              string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientTemplateScopeMappingsClientCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientTemplateScopeMappingsClientCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientTemplateScopeMappingsClientCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsClientCompositeExecute(r)
}

/*
GetClientTemplateScopeMappingsClientComposite Method for GetClientTemplateScopeMappingsClientComposite

Get effective client roles Returns the roles for the client that are associated with the client’s scope.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetClientTemplateScopeMappingsClientCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClientComposite(ctx context.Context, realm string, id string, client string) ApiGetClientTemplateScopeMappingsClientCompositeRequest {
	return ApiGetClientTemplateScopeMappingsClientCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsClientCompositeExecute(r ApiGetClientTemplateScopeMappingsClientCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsClientComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsRealmRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientTemplateScopeMappingsRealmRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsRealmExecute(r)
}

/*
GetClientTemplateScopeMappingsRealm Method for GetClientTemplateScopeMappingsRealm

Get realm-level roles associated with the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientTemplateScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealm(ctx context.Context, realm string, id string) ApiGetClientTemplateScopeMappingsRealmRequest {
	return ApiGetClientTemplateScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealmExecute(r ApiGetClientTemplateScopeMappingsRealmRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsRealm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsRealmAvailableRequest struct {
	ctx        context.Context
	ApiService *ScopeMappingsAPIService
	realm      string
	id         string
}

func (r ApiGetClientTemplateScopeMappingsRealmAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsRealmAvailableExecute(r)
}

/*
GetClientTemplateScopeMappingsRealmAvailable Method for GetClientTemplateScopeMappingsRealmAvailable

Get realm-level roles that are available to attach to this client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientTemplateScopeMappingsRealmAvailableRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealmAvailable(ctx context.Context, realm string, id string) ApiGetClientTemplateScopeMappingsRealmAvailableRequest {
	return ApiGetClientTemplateScopeMappingsRealmAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealmAvailableExecute(r ApiGetClientTemplateScopeMappingsRealmAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsRealmAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/realm/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateScopeMappingsRealmCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ScopeMappingsAPIService
	realm               string
	id                  string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetClientTemplateScopeMappingsRealmCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetClientTemplateScopeMappingsRealmCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientTemplateScopeMappingsRealmCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateScopeMappingsRealmCompositeExecute(r)
}

/*
GetClientTemplateScopeMappingsRealmComposite Method for GetClientTemplateScopeMappingsRealmComposite

Get effective realm-level roles associated with the client’s scope What this does is recurse any composite roles associated with the client’s scope and adds the roles to this lists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientTemplateScopeMappingsRealmCompositeRequest
*/
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealmComposite(ctx context.Context, realm string, id string) ApiGetClientTemplateScopeMappingsRealmCompositeRequest {
	return ApiGetClientTemplateScopeMappingsRealmCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ScopeMappingsAPIService) GetClientTemplateScopeMappingsRealmCompositeExecute(r ApiGetClientTemplateScopeMappingsRealmCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.GetClientTemplateScopeMappingsRealmComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/realm/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostClientScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeMappingsClientExecute(r)
}

/*
PostClientScopeMappingsClient Method for PostClientScopeMappingsClient

Add client-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiPostClientScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) PostClientScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiPostClientScopeMappingsClientRequest {
	return ApiPostClientScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientScopeMappingsClientExecute(r ApiPostClientScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeMappingsRealmExecute(r)
}

/*
PostClientScopeMappingsRealm Method for PostClientScopeMappingsRealm

Add a set of realm-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) PostClientScopeMappingsRealm(ctx context.Context, realm string, id string) ApiPostClientScopeMappingsRealmRequest {
	return ApiPostClientScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientScopeMappingsRealmExecute(r ApiPostClientScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientScopeScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientScopeScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientScopeScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientScopeScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeScopeMappingsClientExecute(r)
}

/*
PostClientScopeScopeMappingsClient Method for PostClientScopeScopeMappingsClient

Add client-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiPostClientScopeScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) PostClientScopeScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiPostClientScopeScopeMappingsClientRequest {
	return ApiPostClientScopeScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientScopeScopeMappingsClientExecute(r ApiPostClientScopeScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientScopeScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientScopeScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientScopeScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientScopeScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientScopeScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeScopeMappingsRealmExecute(r)
}

/*
PostClientScopeScopeMappingsRealm Method for PostClientScopeScopeMappingsRealm

Add a set of realm-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientScopeScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) PostClientScopeScopeMappingsRealm(ctx context.Context, realm string, id string) ApiPostClientScopeScopeMappingsRealmRequest {
	return ApiPostClientScopeScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientScopeScopeMappingsRealmExecute(r ApiPostClientScopeScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientScopeScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientTemplateScopeMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientTemplateScopeMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientTemplateScopeMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientTemplateScopeMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientTemplateScopeMappingsClientExecute(r)
}

/*
PostClientTemplateScopeMappingsClient Method for PostClientTemplateScopeMappingsClient

Add client-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiPostClientTemplateScopeMappingsClientRequest
*/
func (a *ScopeMappingsAPIService) PostClientTemplateScopeMappingsClient(ctx context.Context, realm string, id string, client string) ApiPostClientTemplateScopeMappingsClientRequest {
	return ApiPostClientTemplateScopeMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientTemplateScopeMappingsClientExecute(r ApiPostClientTemplateScopeMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientTemplateScopeMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientTemplateScopeMappingsRealmRequest struct {
	ctx                context.Context
	ApiService         *ScopeMappingsAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientTemplateScopeMappingsRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientTemplateScopeMappingsRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientTemplateScopeMappingsRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientTemplateScopeMappingsRealmExecute(r)
}

/*
PostClientTemplateScopeMappingsRealm Method for PostClientTemplateScopeMappingsRealm

Add a set of realm-level roles to the client’s scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientTemplateScopeMappingsRealmRequest
*/
func (a *ScopeMappingsAPIService) PostClientTemplateScopeMappingsRealm(ctx context.Context, realm string, id string) ApiPostClientTemplateScopeMappingsRealmRequest {
	return ApiPostClientTemplateScopeMappingsRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ScopeMappingsAPIService) PostClientTemplateScopeMappingsRealmExecute(r ApiPostClientTemplateScopeMappingsRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScopeMappingsAPIService.PostClientTemplateScopeMappingsRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/scope-mappings/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
