/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ProtocolMappersAPIService ProtocolMappersAPI service
type ProtocolMappersAPIService service

type ApiDeleteClientProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiDeleteClientProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientProtocolMappersModelExecute(r)
}

/*
DeleteClientProtocolMappersModel Method for DeleteClientProtocolMappersModel

Delete the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiDeleteClientProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) DeleteClientProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiDeleteClientProtocolMappersModelRequest {
	return ApiDeleteClientProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) DeleteClientProtocolMappersModelExecute(r ApiDeleteClientProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.DeleteClientProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientScopeProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiDeleteClientScopeProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientScopeProtocolMappersModelExecute(r)
}

/*
DeleteClientScopeProtocolMappersModel Method for DeleteClientScopeProtocolMappersModel

Delete the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiDeleteClientScopeProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) DeleteClientScopeProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiDeleteClientScopeProtocolMappersModelRequest {
	return ApiDeleteClientScopeProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) DeleteClientScopeProtocolMappersModelExecute(r ApiDeleteClientScopeProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.DeleteClientScopeProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientTemplateProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiDeleteClientTemplateProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientTemplateProtocolMappersModelExecute(r)
}

/*
DeleteClientTemplateProtocolMappersModel Method for DeleteClientTemplateProtocolMappersModel

Delete the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiDeleteClientTemplateProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) DeleteClientTemplateProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiDeleteClientTemplateProtocolMappersModelRequest {
	return ApiDeleteClientTemplateProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) DeleteClientTemplateProtocolMappersModelExecute(r ApiDeleteClientTemplateProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.DeleteClientTemplateProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetClientProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiGetClientProtocolMappersModelRequest) Execute() (*ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientProtocolMappersModelExecute(r)
}

/*
GetClientProtocolMappersModel Method for GetClientProtocolMappersModel

Get mapper by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiGetClientProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) GetClientProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiGetClientProtocolMappersModelRequest {
	return ApiGetClientProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
//
//	@return ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientProtocolMappersModelExecute(r ApiGetClientProtocolMappersModelRequest) (*ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientProtocolMappersModel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientProtocolMappersModelsRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
}

func (r ApiGetClientProtocolMappersModelsRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientProtocolMappersModelsExecute(r)
}

/*
GetClientProtocolMappersModels Method for GetClientProtocolMappersModels

Get mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) GetClientProtocolMappersModels(ctx context.Context, realm string, id string) ApiGetClientProtocolMappersModelsRequest {
	return ApiGetClientProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientProtocolMappersModelsExecute(r ApiGetClientProtocolMappersModelsRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientProtocolMappersModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientProtocolMappersProtocolRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
	protocol   string
}

func (r ApiGetClientProtocolMappersProtocolRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientProtocolMappersProtocolExecute(r)
}

/*
GetClientProtocolMappersProtocol Method for GetClientProtocolMappersProtocol

Get mappers by name for a specific protocol

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param protocol
	@return ApiGetClientProtocolMappersProtocolRequest
*/
func (a *ProtocolMappersAPIService) GetClientProtocolMappersProtocol(ctx context.Context, realm string, id string, protocol string) ApiGetClientProtocolMappersProtocolRequest {
	return ApiGetClientProtocolMappersProtocolRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		protocol:   protocol,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientProtocolMappersProtocolExecute(r ApiGetClientProtocolMappersProtocolRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientProtocolMappersProtocol")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", url.PathEscape(parameterValueToString(r.protocol, "protocol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiGetClientScopeProtocolMappersModelRequest) Execute() (*ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeProtocolMappersModelExecute(r)
}

/*
GetClientScopeProtocolMappersModel Method for GetClientScopeProtocolMappersModel

Get mapper by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiGetClientScopeProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiGetClientScopeProtocolMappersModelRequest {
	return ApiGetClientScopeProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
//
//	@return ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersModelExecute(r ApiGetClientScopeProtocolMappersModelRequest) (*ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientScopeProtocolMappersModel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeProtocolMappersModelsRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
}

func (r ApiGetClientScopeProtocolMappersModelsRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeProtocolMappersModelsExecute(r)
}

/*
GetClientScopeProtocolMappersModels Method for GetClientScopeProtocolMappersModels

Get mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientScopeProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersModels(ctx context.Context, realm string, id string) ApiGetClientScopeProtocolMappersModelsRequest {
	return ApiGetClientScopeProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersModelsExecute(r ApiGetClientScopeProtocolMappersModelsRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientScopeProtocolMappersModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientScopeProtocolMappersProtocolRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
	protocol   string
}

func (r ApiGetClientScopeProtocolMappersProtocolRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientScopeProtocolMappersProtocolExecute(r)
}

/*
GetClientScopeProtocolMappersProtocol Method for GetClientScopeProtocolMappersProtocol

Get mappers by name for a specific protocol

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param protocol
	@return ApiGetClientScopeProtocolMappersProtocolRequest
*/
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersProtocol(ctx context.Context, realm string, id string, protocol string) ApiGetClientScopeProtocolMappersProtocolRequest {
	return ApiGetClientScopeProtocolMappersProtocolRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		protocol:   protocol,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientScopeProtocolMappersProtocolExecute(r ApiGetClientScopeProtocolMappersProtocolRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientScopeProtocolMappersProtocol")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/protocol-mappers/protocol/{protocol}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", url.PathEscape(parameterValueToString(r.protocol, "protocol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateProtocolMappersModelRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id1        string
	id2        string
}

func (r ApiGetClientTemplateProtocolMappersModelRequest) Execute() (*ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateProtocolMappersModelExecute(r)
}

/*
GetClientTemplateProtocolMappersModel Method for GetClientTemplateProtocolMappersModel

Get mapper by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiGetClientTemplateProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiGetClientTemplateProtocolMappersModelRequest {
	return ApiGetClientTemplateProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
//
//	@return ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersModelExecute(r ApiGetClientTemplateProtocolMappersModelRequest) (*ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientTemplateProtocolMappersModel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateProtocolMappersModelsRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
}

func (r ApiGetClientTemplateProtocolMappersModelsRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateProtocolMappersModelsExecute(r)
}

/*
GetClientTemplateProtocolMappersModels Method for GetClientTemplateProtocolMappersModels

Get mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientTemplateProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersModels(ctx context.Context, realm string, id string) ApiGetClientTemplateProtocolMappersModelsRequest {
	return ApiGetClientTemplateProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersModelsExecute(r ApiGetClientTemplateProtocolMappersModelsRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientTemplateProtocolMappersModels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientTemplateProtocolMappersProtocolRequest struct {
	ctx        context.Context
	ApiService *ProtocolMappersAPIService
	realm      string
	id         string
	protocol   string
}

func (r ApiGetClientTemplateProtocolMappersProtocolRequest) Execute() ([]ProtocolMapperRepresentation, *http.Response, error) {
	return r.ApiService.GetClientTemplateProtocolMappersProtocolExecute(r)
}

/*
GetClientTemplateProtocolMappersProtocol Method for GetClientTemplateProtocolMappersProtocol

Get mappers by name for a specific protocol

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param protocol
	@return ApiGetClientTemplateProtocolMappersProtocolRequest
*/
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersProtocol(ctx context.Context, realm string, id string, protocol string) ApiGetClientTemplateProtocolMappersProtocolRequest {
	return ApiGetClientTemplateProtocolMappersProtocolRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		protocol:   protocol,
	}
}

// Execute executes the request
//
//	@return []ProtocolMapperRepresentation
func (a *ProtocolMappersAPIService) GetClientTemplateProtocolMappersProtocolExecute(r ApiGetClientTemplateProtocolMappersProtocolRequest) ([]ProtocolMapperRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProtocolMapperRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.GetClientTemplateProtocolMappersProtocol")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/protocol-mappers/protocol/{protocol}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", url.PathEscape(parameterValueToString(r.protocol, "protocol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostClientProtocolMappersAddModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientProtocolMappersAddModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientProtocolMappersAddModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientProtocolMappersAddModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientProtocolMappersAddModelsExecute(r)
}

/*
PostClientProtocolMappersAddModels Method for PostClientProtocolMappersAddModels

Create multiple mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientProtocolMappersAddModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientProtocolMappersAddModels(ctx context.Context, realm string, id string) ApiPostClientProtocolMappersAddModelsRequest {
	return ApiPostClientProtocolMappersAddModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientProtocolMappersAddModelsExecute(r ApiPostClientProtocolMappersAddModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientProtocolMappersAddModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/protocol-mappers/add-models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientProtocolMappersModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientProtocolMappersModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientProtocolMappersModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientProtocolMappersModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientProtocolMappersModelsExecute(r)
}

/*
PostClientProtocolMappersModels Method for PostClientProtocolMappersModels

Create a mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientProtocolMappersModels(ctx context.Context, realm string, id string) ApiPostClientProtocolMappersModelsRequest {
	return ApiPostClientProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientProtocolMappersModelsExecute(r ApiPostClientProtocolMappersModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientProtocolMappersModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientScopeProtocolMappersAddModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientScopeProtocolMappersAddModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientScopeProtocolMappersAddModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientScopeProtocolMappersAddModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeProtocolMappersAddModelsExecute(r)
}

/*
PostClientScopeProtocolMappersAddModels Method for PostClientScopeProtocolMappersAddModels

Create multiple mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientScopeProtocolMappersAddModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientScopeProtocolMappersAddModels(ctx context.Context, realm string, id string) ApiPostClientScopeProtocolMappersAddModelsRequest {
	return ApiPostClientScopeProtocolMappersAddModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientScopeProtocolMappersAddModelsExecute(r ApiPostClientScopeProtocolMappersAddModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientScopeProtocolMappersAddModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/protocol-mappers/add-models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientScopeProtocolMappersModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientScopeProtocolMappersModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientScopeProtocolMappersModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientScopeProtocolMappersModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientScopeProtocolMappersModelsExecute(r)
}

/*
PostClientScopeProtocolMappersModels Method for PostClientScopeProtocolMappersModels

Create a mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientScopeProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientScopeProtocolMappersModels(ctx context.Context, realm string, id string) ApiPostClientScopeProtocolMappersModelsRequest {
	return ApiPostClientScopeProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientScopeProtocolMappersModelsExecute(r ApiPostClientScopeProtocolMappersModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientScopeProtocolMappersModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientTemplateProtocolMappersAddModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientTemplateProtocolMappersAddModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientTemplateProtocolMappersAddModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientTemplateProtocolMappersAddModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientTemplateProtocolMappersAddModelsExecute(r)
}

/*
PostClientTemplateProtocolMappersAddModels Method for PostClientTemplateProtocolMappersAddModels

Create multiple mappers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientTemplateProtocolMappersAddModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientTemplateProtocolMappersAddModels(ctx context.Context, realm string, id string) ApiPostClientTemplateProtocolMappersAddModelsRequest {
	return ApiPostClientTemplateProtocolMappersAddModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientTemplateProtocolMappersAddModelsExecute(r ApiPostClientTemplateProtocolMappersAddModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientTemplateProtocolMappersAddModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/protocol-mappers/add-models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientTemplateProtocolMappersModelsRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id                           string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPostClientTemplateProtocolMappersModelsRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPostClientTemplateProtocolMappersModelsRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPostClientTemplateProtocolMappersModelsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientTemplateProtocolMappersModelsExecute(r)
}

/*
PostClientTemplateProtocolMappersModels Method for PostClientTemplateProtocolMappersModels

Create a mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientTemplateProtocolMappersModelsRequest
*/
func (a *ProtocolMappersAPIService) PostClientTemplateProtocolMappersModels(ctx context.Context, realm string, id string) ApiPostClientTemplateProtocolMappersModelsRequest {
	return ApiPostClientTemplateProtocolMappersModelsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PostClientTemplateProtocolMappersModelsExecute(r ApiPostClientTemplateProtocolMappersModelsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PostClientTemplateProtocolMappersModels")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id}/protocol-mappers/models"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutClientProtocolMappersModelRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id1                          string
	id2                          string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPutClientProtocolMappersModelRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPutClientProtocolMappersModelRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPutClientProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutClientProtocolMappersModelExecute(r)
}

/*
PutClientProtocolMappersModel Method for PutClientProtocolMappersModel

Update the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiPutClientProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) PutClientProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiPutClientProtocolMappersModelRequest {
	return ApiPutClientProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PutClientProtocolMappersModelExecute(r ApiPutClientProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PutClientProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutClientScopeProtocolMappersModelRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id1                          string
	id2                          string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPutClientScopeProtocolMappersModelRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPutClientScopeProtocolMappersModelRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPutClientScopeProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutClientScopeProtocolMappersModelExecute(r)
}

/*
PutClientScopeProtocolMappersModel Method for PutClientScopeProtocolMappersModel

Update the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiPutClientScopeProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) PutClientScopeProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiPutClientScopeProtocolMappersModelRequest {
	return ApiPutClientScopeProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PutClientScopeProtocolMappersModelExecute(r ApiPutClientScopeProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PutClientScopeProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-scopes/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutClientTemplateProtocolMappersModelRequest struct {
	ctx                          context.Context
	ApiService                   *ProtocolMappersAPIService
	realm                        string
	id1                          string
	id2                          string
	protocolMapperRepresentation *ProtocolMapperRepresentation
}

// ProtocolMapperRepresentation
func (r ApiPutClientTemplateProtocolMappersModelRequest) ProtocolMapperRepresentation(protocolMapperRepresentation ProtocolMapperRepresentation) ApiPutClientTemplateProtocolMappersModelRequest {
	r.protocolMapperRepresentation = &protocolMapperRepresentation
	return r
}

func (r ApiPutClientTemplateProtocolMappersModelRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutClientTemplateProtocolMappersModelExecute(r)
}

/*
PutClientTemplateProtocolMappersModel Method for PutClientTemplateProtocolMappersModel

Update the mapper

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id1
	@param id2
	@return ApiPutClientTemplateProtocolMappersModelRequest
*/
func (a *ProtocolMappersAPIService) PutClientTemplateProtocolMappersModel(ctx context.Context, realm string, id1 string, id2 string) ApiPutClientTemplateProtocolMappersModelRequest {
	return ApiPutClientTemplateProtocolMappersModelRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id1:        id1,
		id2:        id2,
	}
}

// Execute executes the request
func (a *ProtocolMappersAPIService) PutClientTemplateProtocolMappersModelExecute(r ApiPutClientTemplateProtocolMappersModelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtocolMappersAPIService.PutClientTemplateProtocolMappersModel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/client-templates/{id1}/protocol-mappers/models/{id2}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id1"+"}", url.PathEscape(parameterValueToString(r.id1, "id1")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id2"+"}", url.PathEscape(parameterValueToString(r.id2, "id2")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protocolMapperRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
