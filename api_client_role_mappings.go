/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ClientRoleMappingsAPIService ClientRoleMappingsAPI service
type ClientRoleMappingsAPIService service

type ApiDeleteGroupRoleMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ClientRoleMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteGroupRoleMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteGroupRoleMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteGroupRoleMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGroupRoleMappingsClientExecute(r)
}

/*
DeleteGroupRoleMappingsClient Method for DeleteGroupRoleMappingsClient

Delete client-level roles from user role mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiDeleteGroupRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) DeleteGroupRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiDeleteGroupRoleMappingsClientRequest {
	return ApiDeleteGroupRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ClientRoleMappingsAPIService) DeleteGroupRoleMappingsClientExecute(r ApiDeleteGroupRoleMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.DeleteGroupRoleMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/groups/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserRoleMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ClientRoleMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteUserRoleMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteUserRoleMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteUserRoleMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserRoleMappingsClientExecute(r)
}

/*
DeleteUserRoleMappingsClient Method for DeleteUserRoleMappingsClient

Delete client-level roles from user role mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiDeleteUserRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) DeleteUserRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiDeleteUserRoleMappingsClientRequest {
	return ApiDeleteUserRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ClientRoleMappingsAPIService) DeleteUserRoleMappingsClientExecute(r ApiDeleteUserRoleMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.DeleteUserRoleMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/users/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupRoleMappingsClientRequest struct {
	ctx        context.Context
	ApiService *ClientRoleMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetGroupRoleMappingsClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetGroupRoleMappingsClientExecute(r)
}

/*
GetGroupRoleMappingsClient Method for GetGroupRoleMappingsClient

Get client-level role mappings for the user, and the app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetGroupRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiGetGroupRoleMappingsClientRequest {
	return ApiGetGroupRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClientExecute(r ApiGetGroupRoleMappingsClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetGroupRoleMappingsClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/groups/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupRoleMappingsClientAvailableRequest struct {
	ctx        context.Context
	ApiService *ClientRoleMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetGroupRoleMappingsClientAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetGroupRoleMappingsClientAvailableExecute(r)
}

/*
GetGroupRoleMappingsClientAvailable Method for GetGroupRoleMappingsClientAvailable

Get available client-level roles that can be mapped to the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetGroupRoleMappingsClientAvailableRequest
*/
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClientAvailable(ctx context.Context, realm string, id string, client string) ApiGetGroupRoleMappingsClientAvailableRequest {
	return ApiGetGroupRoleMappingsClientAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClientAvailableExecute(r ApiGetGroupRoleMappingsClientAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetGroupRoleMappingsClientAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/groups/{id}/role-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupRoleMappingsClientCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ClientRoleMappingsAPIService
	realm               string
	id                  string
	client              string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetGroupRoleMappingsClientCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetGroupRoleMappingsClientCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetGroupRoleMappingsClientCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetGroupRoleMappingsClientCompositeExecute(r)
}

/*
GetGroupRoleMappingsClientComposite Method for GetGroupRoleMappingsClientComposite

Get effective client-level role mappings This recurses any composite roles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetGroupRoleMappingsClientCompositeRequest
*/
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClientComposite(ctx context.Context, realm string, id string, client string) ApiGetGroupRoleMappingsClientCompositeRequest {
	return ApiGetGroupRoleMappingsClientCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetGroupRoleMappingsClientCompositeExecute(r ApiGetGroupRoleMappingsClientCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetGroupRoleMappingsClientComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/groups/{id}/role-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRoleMappingsClientRequest struct {
	ctx        context.Context
	ApiService *ClientRoleMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetUserRoleMappingsClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetUserRoleMappingsClientExecute(r)
}

/*
GetUserRoleMappingsClient Method for GetUserRoleMappingsClient

Get client-level role mappings for the user, and the app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetUserRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiGetUserRoleMappingsClientRequest {
	return ApiGetUserRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClientExecute(r ApiGetUserRoleMappingsClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetUserRoleMappingsClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/users/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRoleMappingsClientAvailableRequest struct {
	ctx        context.Context
	ApiService *ClientRoleMappingsAPIService
	realm      string
	id         string
	client     string
}

func (r ApiGetUserRoleMappingsClientAvailableRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetUserRoleMappingsClientAvailableExecute(r)
}

/*
GetUserRoleMappingsClientAvailable Method for GetUserRoleMappingsClientAvailable

Get available client-level roles that can be mapped to the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetUserRoleMappingsClientAvailableRequest
*/
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClientAvailable(ctx context.Context, realm string, id string, client string) ApiGetUserRoleMappingsClientAvailableRequest {
	return ApiGetUserRoleMappingsClientAvailableRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClientAvailableExecute(r ApiGetUserRoleMappingsClientAvailableRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetUserRoleMappingsClientAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/users/{id}/role-mappings/clients/{client}/available"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRoleMappingsClientCompositeRequest struct {
	ctx                 context.Context
	ApiService          *ClientRoleMappingsAPIService
	realm               string
	id                  string
	client              string
	briefRepresentation *string
}

// if false, return roles with their attributes
func (r ApiGetUserRoleMappingsClientCompositeRequest) BriefRepresentation(briefRepresentation string) ApiGetUserRoleMappingsClientCompositeRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetUserRoleMappingsClientCompositeRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetUserRoleMappingsClientCompositeExecute(r)
}

/*
GetUserRoleMappingsClientComposite Method for GetUserRoleMappingsClientComposite

Get effective client-level role mappings This recurses any composite roles

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiGetUserRoleMappingsClientCompositeRequest
*/
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClientComposite(ctx context.Context, realm string, id string, client string) ApiGetUserRoleMappingsClientCompositeRequest {
	return ApiGetUserRoleMappingsClientCompositeRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *ClientRoleMappingsAPIService) GetUserRoleMappingsClientCompositeExecute(r ApiGetUserRoleMappingsClientCompositeRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.GetUserRoleMappingsClientComposite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/users/{id}/role-mappings/clients/{client}/composite"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostGroupRoleMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ClientRoleMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostGroupRoleMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostGroupRoleMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostGroupRoleMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostGroupRoleMappingsClientExecute(r)
}

/*
PostGroupRoleMappingsClient Method for PostGroupRoleMappingsClient

Add client-level roles to the user role mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiPostGroupRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) PostGroupRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiPostGroupRoleMappingsClientRequest {
	return ApiPostGroupRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ClientRoleMappingsAPIService) PostGroupRoleMappingsClientExecute(r ApiPostGroupRoleMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.PostGroupRoleMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/groups/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostUserRoleMappingsClientRequest struct {
	ctx                context.Context
	ApiService         *ClientRoleMappingsAPIService
	realm              string
	id                 string
	client             string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostUserRoleMappingsClientRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostUserRoleMappingsClientRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostUserRoleMappingsClientRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUserRoleMappingsClientExecute(r)
}

/*
PostUserRoleMappingsClient Method for PostUserRoleMappingsClient

Add client-level roles to the user role mapping

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param client
	@return ApiPostUserRoleMappingsClientRequest
*/
func (a *ClientRoleMappingsAPIService) PostUserRoleMappingsClient(ctx context.Context, realm string, id string, client string) ApiPostUserRoleMappingsClientRequest {
	return ApiPostUserRoleMappingsClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		client:     client,
	}
}

// Execute executes the request
func (a *ClientRoleMappingsAPIService) PostUserRoleMappingsClientExecute(r ApiPostUserRoleMappingsClientRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ClientRoleMappingsAPIService.PostUserRoleMappingsClient")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/users/{id}/role-mappings/clients/{client}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client"+"}", url.PathEscape(parameterValueToString(r.client, "client")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
