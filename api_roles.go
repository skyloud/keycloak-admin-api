/*
Keycloak Admin REST API

This is a REST API reference for the Keycloak Admin REST API.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// RolesAPIService RolesAPI service
type RolesAPIService service

type ApiDeleteClientRoleRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
}

func (r ApiDeleteClientRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientRoleExecute(r)
}

/*
DeleteClientRole Method for DeleteClientRole

Delete a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiDeleteClientRoleRequest
*/
func (a *RolesAPIService) DeleteClientRole(ctx context.Context, realm string, id string, roleName string) ApiDeleteClientRoleRequest {
	return ApiDeleteClientRoleRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) DeleteClientRoleExecute(r ApiDeleteClientRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.DeleteClientRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteClientRoleCompositesRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	id                 string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteClientRoleCompositesRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteClientRoleCompositesRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteClientRoleCompositesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteClientRoleCompositesExecute(r)
}

/*
DeleteClientRoleComposites Method for DeleteClientRoleComposites

Remove roles from the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiDeleteClientRoleCompositesRequest
*/
func (a *RolesAPIService) DeleteClientRoleComposites(ctx context.Context, realm string, id string, roleName string) ApiDeleteClientRoleCompositesRequest {
	return ApiDeleteClientRoleCompositesRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) DeleteClientRoleCompositesExecute(r ApiDeleteClientRoleCompositesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.DeleteClientRoleComposites")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRoleByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
}

func (r ApiDeleteRoleByRealmByRoleNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleByRealmByRoleNameExecute(r)
}

/*
DeleteRoleByRealmByRoleName Method for DeleteRoleByRealmByRoleName

Delete a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiDeleteRoleByRealmByRoleNameRequest
*/
func (a *RolesAPIService) DeleteRoleByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiDeleteRoleByRealmByRoleNameRequest {
	return ApiDeleteRoleByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) DeleteRoleByRealmByRoleNameExecute(r ApiDeleteRoleByRealmByRoleNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.DeleteRoleByRealmByRoleName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRoleCompositesByRealmByRoleNameRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiDeleteRoleCompositesByRealmByRoleNameRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiDeleteRoleCompositesByRealmByRoleNameRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiDeleteRoleCompositesByRealmByRoleNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleCompositesByRealmByRoleNameExecute(r)
}

/*
DeleteRoleCompositesByRealmByRoleName Method for DeleteRoleCompositesByRealmByRoleName

Remove roles from the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiDeleteRoleCompositesByRealmByRoleNameRequest
*/
func (a *RolesAPIService) DeleteRoleCompositesByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiDeleteRoleCompositesByRealmByRoleNameRequest {
	return ApiDeleteRoleCompositesByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) DeleteRoleCompositesByRealmByRoleNameExecute(r ApiDeleteRoleCompositesByRealmByRoleNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.DeleteRoleCompositesByRealmByRoleName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetClientRoleRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
}

func (r ApiGetClientRoleRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleExecute(r)
}

/*
GetClientRole Method for GetClientRole

Get a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiGetClientRoleRequest
*/
func (a *RolesAPIService) GetClientRole(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleRequest {
	return ApiGetClientRoleRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return RoleRepresentation
func (a *RolesAPIService) GetClientRoleExecute(r ApiGetClientRoleRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleCompositesRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
}

func (r ApiGetClientRoleCompositesRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleCompositesExecute(r)
}

/*
GetClientRoleComposites Method for GetClientRoleComposites

Get composites of the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiGetClientRoleCompositesRequest
*/
func (a *RolesAPIService) GetClientRoleComposites(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleCompositesRequest {
	return ApiGetClientRoleCompositesRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetClientRoleCompositesExecute(r ApiGetClientRoleCompositesRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleComposites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleCompositesClientRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
	clientUuid string
}

func (r ApiGetClientRoleCompositesClientRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleCompositesClientExecute(r)
}

/*
GetClientRoleCompositesClient Method for GetClientRoleCompositesClient

Get client-level roles for the client that are in the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@param clientUuid
	@return ApiGetClientRoleCompositesClientRequest
*/
func (a *RolesAPIService) GetClientRoleCompositesClient(ctx context.Context, realm string, id string, roleName string, clientUuid string) ApiGetClientRoleCompositesClientRequest {
	return ApiGetClientRoleCompositesClientRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetClientRoleCompositesClientExecute(r ApiGetClientRoleCompositesClientRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleCompositesClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/composites/clients/{clientUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientUuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleCompositesRealmRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
}

func (r ApiGetClientRoleCompositesRealmRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleCompositesRealmExecute(r)
}

/*
GetClientRoleCompositesRealm Method for GetClientRoleCompositesRealm

Get realm-level roles of the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiGetClientRoleCompositesRealmRequest
*/
func (a *RolesAPIService) GetClientRoleCompositesRealm(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleCompositesRealmRequest {
	return ApiGetClientRoleCompositesRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetClientRoleCompositesRealmExecute(r ApiGetClientRoleCompositesRealmRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleCompositesRealm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleGroupsRequest struct {
	ctx                 context.Context
	ApiService          *RolesAPIService
	realm               string
	id                  string
	roleName            string
	briefRepresentation *string
	first               *string
	max                 *string
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r ApiGetClientRoleGroupsRequest) BriefRepresentation(briefRepresentation string) ApiGetClientRoleGroupsRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiGetClientRoleGroupsRequest) First(first string) ApiGetClientRoleGroupsRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiGetClientRoleGroupsRequest) Max(max string) ApiGetClientRoleGroupsRequest {
	r.max = &max
	return r
}

func (r ApiGetClientRoleGroupsRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleGroupsExecute(r)
}

/*
GetClientRoleGroups Method for GetClientRoleGroups

Returns a stream of groups that have the specified role name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName the role name.
	@return ApiGetClientRoleGroupsRequest
*/
func (a *RolesAPIService) GetClientRoleGroups(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleGroupsRequest {
	return ApiGetClientRoleGroupsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []GroupRepresentation
func (a *RolesAPIService) GetClientRoleGroupsExecute(r ApiGetClientRoleGroupsRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleManagementPermissionsRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
}

func (r ApiGetClientRoleManagementPermissionsRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.GetClientRoleManagementPermissionsExecute(r)
}

/*
GetClientRoleManagementPermissions Method for GetClientRoleManagementPermissions

Return object stating whether role Authorization permissions have been initialized or not and a reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName
	@return ApiGetClientRoleManagementPermissionsRequest
*/
func (a *RolesAPIService) GetClientRoleManagementPermissions(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleManagementPermissionsRequest {
	return ApiGetClientRoleManagementPermissionsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return ManagementPermissionReference
func (a *RolesAPIService) GetClientRoleManagementPermissionsExecute(r ApiGetClientRoleManagementPermissionsRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleManagementPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRoleUsersRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	id         string
	roleName   string
	first      *string
	max        *string
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiGetClientRoleUsersRequest) First(first string) ApiGetClientRoleUsersRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiGetClientRoleUsersRequest) Max(max string) ApiGetClientRoleUsersRequest {
	r.max = &max
	return r
}

func (r ApiGetClientRoleUsersRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRoleUsersExecute(r)
}

/*
GetClientRoleUsers Method for GetClientRoleUsers

Returns a stream of users that have the specified role name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName the role name.
	@return ApiGetClientRoleUsersRequest
*/
func (a *RolesAPIService) GetClientRoleUsers(ctx context.Context, realm string, id string, roleName string) ApiGetClientRoleUsersRequest {
	return ApiGetClientRoleUsersRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []UserRepresentation
func (a *RolesAPIService) GetClientRoleUsersExecute(r ApiGetClientRoleUsersRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoleUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClientRolesRequest struct {
	ctx                 context.Context
	ApiService          *RolesAPIService
	realm               string
	id                  string
	briefRepresentation *string
	first               *string
	max                 *string
	search              *string
}

func (r ApiGetClientRolesRequest) BriefRepresentation(briefRepresentation string) ApiGetClientRolesRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetClientRolesRequest) First(first string) ApiGetClientRolesRequest {
	r.first = &first
	return r
}

func (r ApiGetClientRolesRequest) Max(max string) ApiGetClientRolesRequest {
	r.max = &max
	return r
}

func (r ApiGetClientRolesRequest) Search(search string) ApiGetClientRolesRequest {
	r.search = &search
	return r
}

func (r ApiGetClientRolesRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetClientRolesExecute(r)
}

/*
GetClientRoles Method for GetClientRoles

Get all roles for the realm or client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiGetClientRolesRequest
*/
func (a *RolesAPIService) GetClientRoles(ctx context.Context, realm string, id string) ApiGetClientRolesRequest {
	return ApiGetClientRolesRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetClientRolesExecute(r ApiGetClientRolesRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetClientRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
}

func (r ApiGetRoleByRealmByRoleNameRequest) Execute() (*RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleByRealmByRoleNameExecute(r)
}

/*
GetRoleByRealmByRoleName Method for GetRoleByRealmByRoleName

Get a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiGetRoleByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleByRealmByRoleNameRequest {
	return ApiGetRoleByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return RoleRepresentation
func (a *RolesAPIService) GetRoleByRealmByRoleNameExecute(r ApiGetRoleByRealmByRoleNameRequest) (*RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleCompositesByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
}

func (r ApiGetRoleCompositesByRealmByRoleNameRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleCompositesByRealmByRoleNameExecute(r)
}

/*
GetRoleCompositesByRealmByRoleName Method for GetRoleCompositesByRealmByRoleName

Get composites of the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiGetRoleCompositesByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleCompositesByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleCompositesByRealmByRoleNameRequest {
	return ApiGetRoleCompositesByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetRoleCompositesByRealmByRoleNameExecute(r ApiGetRoleCompositesByRealmByRoleNameRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleCompositesByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
	clientUuid string
}

func (r ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleCompositesClientByRealmByRoleNameByClientUuidExecute(r)
}

/*
GetRoleCompositesClientByRealmByRoleNameByClientUuid Method for GetRoleCompositesClientByRealmByRoleNameByClientUuid

Get client-level roles for the client that are in the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@param clientUuid
	@return ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest
*/
func (a *RolesAPIService) GetRoleCompositesClientByRealmByRoleNameByClientUuid(ctx context.Context, realm string, roleName string, clientUuid string) ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest {
	return ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
		clientUuid: clientUuid,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetRoleCompositesClientByRealmByRoleNameByClientUuidExecute(r ApiGetRoleCompositesClientByRealmByRoleNameByClientUuidRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleCompositesClientByRealmByRoleNameByClientUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/composites/clients/{clientUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clientUuid"+"}", url.PathEscape(parameterValueToString(r.clientUuid, "clientUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleCompositesRealmByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
}

func (r ApiGetRoleCompositesRealmByRealmByRoleNameRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleCompositesRealmByRealmByRoleNameExecute(r)
}

/*
GetRoleCompositesRealmByRealmByRoleName Method for GetRoleCompositesRealmByRealmByRoleName

Get realm-level roles of the role’s composite

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiGetRoleCompositesRealmByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleCompositesRealmByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleCompositesRealmByRealmByRoleNameRequest {
	return ApiGetRoleCompositesRealmByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetRoleCompositesRealmByRealmByRoleNameExecute(r ApiGetRoleCompositesRealmByRealmByRoleNameRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleCompositesRealmByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/composites/realm"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleGroupsByRealmByRoleNameRequest struct {
	ctx                 context.Context
	ApiService          *RolesAPIService
	realm               string
	roleName            string
	briefRepresentation *string
	first               *string
	max                 *string
}

// if false, return a full representation of the {@code GroupRepresentation} objects.
func (r ApiGetRoleGroupsByRealmByRoleNameRequest) BriefRepresentation(briefRepresentation string) ApiGetRoleGroupsByRealmByRoleNameRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiGetRoleGroupsByRealmByRoleNameRequest) First(first string) ApiGetRoleGroupsByRealmByRoleNameRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiGetRoleGroupsByRealmByRoleNameRequest) Max(max string) ApiGetRoleGroupsByRealmByRoleNameRequest {
	r.max = &max
	return r
}

func (r ApiGetRoleGroupsByRealmByRoleNameRequest) Execute() ([]GroupRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleGroupsByRealmByRoleNameExecute(r)
}

/*
GetRoleGroupsByRealmByRoleName Method for GetRoleGroupsByRealmByRoleName

Returns a stream of groups that have the specified role name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName the role name.
	@return ApiGetRoleGroupsByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleGroupsByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleGroupsByRealmByRoleNameRequest {
	return ApiGetRoleGroupsByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []GroupRepresentation
func (a *RolesAPIService) GetRoleGroupsByRealmByRoleNameExecute(r ApiGetRoleGroupsByRealmByRoleNameRequest) ([]GroupRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GroupRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleGroupsByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/groups"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleManagementPermissionsByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
}

func (r ApiGetRoleManagementPermissionsByRealmByRoleNameRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.GetRoleManagementPermissionsByRealmByRoleNameExecute(r)
}

/*
GetRoleManagementPermissionsByRealmByRoleName Method for GetRoleManagementPermissionsByRealmByRoleName

Return object stating whether role Authorization permissions have been initialized or not and a reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName
	@return ApiGetRoleManagementPermissionsByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleManagementPermissionsByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleManagementPermissionsByRealmByRoleNameRequest {
	return ApiGetRoleManagementPermissionsByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return ManagementPermissionReference
func (a *RolesAPIService) GetRoleManagementPermissionsByRealmByRoleNameExecute(r ApiGetRoleManagementPermissionsByRealmByRoleNameRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleManagementPermissionsByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRoleUsersByRealmByRoleNameRequest struct {
	ctx        context.Context
	ApiService *RolesAPIService
	realm      string
	roleName   string
	first      *string
	max        *string
}

// first result to return. Ignored if negative or {@code null}.
func (r ApiGetRoleUsersByRealmByRoleNameRequest) First(first string) ApiGetRoleUsersByRealmByRoleNameRequest {
	r.first = &first
	return r
}

// maximum number of results to return. Ignored if negative or {@code null}.
func (r ApiGetRoleUsersByRealmByRoleNameRequest) Max(max string) ApiGetRoleUsersByRealmByRoleNameRequest {
	r.max = &max
	return r
}

func (r ApiGetRoleUsersByRealmByRoleNameRequest) Execute() ([]UserRepresentation, *http.Response, error) {
	return r.ApiService.GetRoleUsersByRealmByRoleNameExecute(r)
}

/*
GetRoleUsersByRealmByRoleName Method for GetRoleUsersByRealmByRoleName

Returns a stream of users that have the specified role name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName the role name.
	@return ApiGetRoleUsersByRealmByRoleNameRequest
*/
func (a *RolesAPIService) GetRoleUsersByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiGetRoleUsersByRealmByRoleNameRequest {
	return ApiGetRoleUsersByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return []UserRepresentation
func (a *RolesAPIService) GetRoleUsersByRealmByRoleNameExecute(r ApiGetRoleUsersByRealmByRoleNameRequest) ([]UserRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []UserRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRoleUsersByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRolesByRealmRequest struct {
	ctx                 context.Context
	ApiService          *RolesAPIService
	realm               string
	briefRepresentation *string
	first               *string
	max                 *string
	search              *string
}

func (r ApiGetRolesByRealmRequest) BriefRepresentation(briefRepresentation string) ApiGetRolesByRealmRequest {
	r.briefRepresentation = &briefRepresentation
	return r
}

func (r ApiGetRolesByRealmRequest) First(first string) ApiGetRolesByRealmRequest {
	r.first = &first
	return r
}

func (r ApiGetRolesByRealmRequest) Max(max string) ApiGetRolesByRealmRequest {
	r.max = &max
	return r
}

func (r ApiGetRolesByRealmRequest) Search(search string) ApiGetRolesByRealmRequest {
	r.search = &search
	return r
}

func (r ApiGetRolesByRealmRequest) Execute() ([]RoleRepresentation, *http.Response, error) {
	return r.ApiService.GetRolesByRealmExecute(r)
}

/*
GetRolesByRealm Method for GetRolesByRealm

Get all roles for the realm or client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return ApiGetRolesByRealmRequest
*/
func (a *RolesAPIService) GetRolesByRealm(ctx context.Context, realm string) ApiGetRolesByRealmRequest {
	return ApiGetRolesByRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
//
//	@return []RoleRepresentation
func (a *RolesAPIService) GetRolesByRealmExecute(r ApiGetRolesByRealmRequest) ([]RoleRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []RoleRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.GetRolesByRealm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.briefRepresentation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "briefRepresentation", r.briefRepresentation, "form", "")
	}
	if r.first != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "first", r.first, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostClientRoleCompositesRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	id                 string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientRoleCompositesRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientRoleCompositesRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientRoleCompositesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientRoleCompositesExecute(r)
}

/*
PostClientRoleComposites Method for PostClientRoleComposites

Add a composite to the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiPostClientRoleCompositesRequest
*/
func (a *RolesAPIService) PostClientRoleComposites(ctx context.Context, realm string, id string, roleName string) ApiPostClientRoleCompositesRequest {
	return ApiPostClientRoleCompositesRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) PostClientRoleCompositesExecute(r ApiPostClientRoleCompositesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PostClientRoleComposites")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostClientRolesRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	id                 string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostClientRolesRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostClientRolesRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostClientRolesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostClientRolesExecute(r)
}

/*
PostClientRoles Method for PostClientRoles

Create a new role for the realm or client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@return ApiPostClientRolesRequest
*/
func (a *RolesAPIService) PostClientRoles(ctx context.Context, realm string, id string) ApiPostClientRolesRequest {
	return ApiPostClientRolesRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
	}
}

// Execute executes the request
func (a *RolesAPIService) PostClientRolesExecute(r ApiPostClientRolesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PostClientRoles")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostRoleCompositesByRealmByRoleNameRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostRoleCompositesByRealmByRoleNameRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostRoleCompositesByRealmByRoleNameRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostRoleCompositesByRealmByRoleNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostRoleCompositesByRealmByRoleNameExecute(r)
}

/*
PostRoleCompositesByRealmByRoleName Method for PostRoleCompositesByRealmByRoleName

Add a composite to the role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiPostRoleCompositesByRealmByRoleNameRequest
*/
func (a *RolesAPIService) PostRoleCompositesByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiPostRoleCompositesByRealmByRoleNameRequest {
	return ApiPostRoleCompositesByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) PostRoleCompositesByRealmByRoleNameExecute(r ApiPostRoleCompositesByRealmByRoleNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PostRoleCompositesByRealmByRoleName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/composites"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostRolesByRealmRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPostRolesByRealmRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPostRolesByRealmRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPostRolesByRealmRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostRolesByRealmExecute(r)
}

/*
PostRolesByRealm Method for PostRolesByRealm

Create a new role for the realm or client

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@return ApiPostRolesByRealmRequest
*/
func (a *RolesAPIService) PostRolesByRealm(ctx context.Context, realm string) ApiPostRolesByRealmRequest {
	return ApiPostRolesByRealmRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
	}
}

// Execute executes the request
func (a *RolesAPIService) PostRolesByRealmExecute(r ApiPostRolesByRealmRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PostRolesByRealm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutClientRoleRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	id                 string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPutClientRoleRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPutClientRoleRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPutClientRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutClientRoleExecute(r)
}

/*
PutClientRole Method for PutClientRole

Update a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName role's name (not id!)
	@return ApiPutClientRoleRequest
*/
func (a *RolesAPIService) PutClientRole(ctx context.Context, realm string, id string, roleName string) ApiPutClientRoleRequest {
	return ApiPutClientRoleRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) PutClientRoleExecute(r ApiPutClientRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PutClientRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutClientRoleManagementPermissionsRequest struct {
	ctx                           context.Context
	ApiService                    *RolesAPIService
	realm                         string
	id                            string
	roleName                      string
	managementPermissionReference *ManagementPermissionReference
}

// ManagementPermissionReference
func (r ApiPutClientRoleManagementPermissionsRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiPutClientRoleManagementPermissionsRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiPutClientRoleManagementPermissionsRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.PutClientRoleManagementPermissionsExecute(r)
}

/*
PutClientRoleManagementPermissions Method for PutClientRoleManagementPermissions

Return object stating whether role Authorization permissions have been initialized or not and a reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param id
	@param roleName
	@return ApiPutClientRoleManagementPermissionsRequest
*/
func (a *RolesAPIService) PutClientRoleManagementPermissions(ctx context.Context, realm string, id string, roleName string) ApiPutClientRoleManagementPermissionsRequest {
	return ApiPutClientRoleManagementPermissionsRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		id:         id,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return ManagementPermissionReference
func (a *RolesAPIService) PutClientRoleManagementPermissionsExecute(r ApiPutClientRoleManagementPermissionsRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PutClientRoleManagementPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/clients/{id}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRoleByRealmByRoleNameRequest struct {
	ctx                context.Context
	ApiService         *RolesAPIService
	realm              string
	roleName           string
	roleRepresentation *RoleRepresentation
}

// RoleRepresentation
func (r ApiPutRoleByRealmByRoleNameRequest) RoleRepresentation(roleRepresentation RoleRepresentation) ApiPutRoleByRealmByRoleNameRequest {
	r.roleRepresentation = &roleRepresentation
	return r
}

func (r ApiPutRoleByRealmByRoleNameRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutRoleByRealmByRoleNameExecute(r)
}

/*
PutRoleByRealmByRoleName Method for PutRoleByRealmByRoleName

Update a role by name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName role's name (not id!)
	@return ApiPutRoleByRealmByRoleNameRequest
*/
func (a *RolesAPIService) PutRoleByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiPutRoleByRealmByRoleNameRequest {
	return ApiPutRoleByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
func (a *RolesAPIService) PutRoleByRealmByRoleNameExecute(r ApiPutRoleByRealmByRoleNameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PutRoleByRealmByRoleName")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleRepresentation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutRoleManagementPermissionsByRealmByRoleNameRequest struct {
	ctx                           context.Context
	ApiService                    *RolesAPIService
	realm                         string
	roleName                      string
	managementPermissionReference *ManagementPermissionReference
}

// ManagementPermissionReference
func (r ApiPutRoleManagementPermissionsByRealmByRoleNameRequest) ManagementPermissionReference(managementPermissionReference ManagementPermissionReference) ApiPutRoleManagementPermissionsByRealmByRoleNameRequest {
	r.managementPermissionReference = &managementPermissionReference
	return r
}

func (r ApiPutRoleManagementPermissionsByRealmByRoleNameRequest) Execute() (*ManagementPermissionReference, *http.Response, error) {
	return r.ApiService.PutRoleManagementPermissionsByRealmByRoleNameExecute(r)
}

/*
PutRoleManagementPermissionsByRealmByRoleName Method for PutRoleManagementPermissionsByRealmByRoleName

Return object stating whether role Authorization permissions have been initialized or not and a reference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param realm realm name (not id!)
	@param roleName
	@return ApiPutRoleManagementPermissionsByRealmByRoleNameRequest
*/
func (a *RolesAPIService) PutRoleManagementPermissionsByRealmByRoleName(ctx context.Context, realm string, roleName string) ApiPutRoleManagementPermissionsByRealmByRoleNameRequest {
	return ApiPutRoleManagementPermissionsByRealmByRoleNameRequest{
		ApiService: a,
		ctx:        ctx,
		realm:      realm,
		roleName:   roleName,
	}
}

// Execute executes the request
//
//	@return ManagementPermissionReference
func (a *RolesAPIService) PutRoleManagementPermissionsByRealmByRoleNameExecute(r ApiPutRoleManagementPermissionsByRealmByRoleNameRequest) (*ManagementPermissionReference, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ManagementPermissionReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolesAPIService.PutRoleManagementPermissionsByRealmByRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{realm}/roles/{role-name}/management/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"realm"+"}", url.PathEscape(parameterValueToString(r.realm, "realm")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role-name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.managementPermissionReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
